struct trace_record {
	u32 cycle;
	u32 pc;
	u32 nextPC;
	u32 lo;
	u32 hi;
	u32[32] regs;
	u32[32] preImageKey;
	u32 preImageOffset;
	u32 heap;
	u8 exitCode;
	bool exited;
//	u32 opcode;
//	u32 addr;
//	u32 memValue;
//	bool isWrite;
//	bool start;
}

struct MipsStates<N> {
	trace_record cur;
	u32[N] memory;
}

def verify_initial_state(trace_record record, u32 start_pc) -> u32 {
	assert(record.cycle == 0);
	assert(record.nextPC == start_pc + 4);
	assert(record.pc == start_pc);
	assert(record.lo == 0);
	assert(record.hi == 0);
	assert(record.regs == [0;32]);
	assert(record.preImageKey == [0;32]);
	assert(record.heap == 0x20000000);
	assert(record.exitCode == 0);
	assert(record.exited == false);
//	assert(record.addr == 0);
//	assert(record.opcode == 0);
//	assert(record.memValue == 0);
//	assert(record.isWrite == 0);
//	assert(record.start == true);

	return 0;
}

def updateReg<N>(MipsStates<N> mut states, u32 reg, u32 value) -> MipsStates<N> {
	assert(reg != 0);
	assert(reg <= 31);
	states.cur.regs[reg] = value;
	return states;
}

def handleJump<N>(MipsStates<N> mut states, u32 link, u32 dest) -> MipsStates<N> {
	u32 prevPC = states.cur.pc;
	states.cur.pc = states.cur.nextPC;
	states.cur.nextPC = dest;
	return if link == 0 {
		states
	} else {
		updateReg(states, link, prevPC + 8)
	};
}

def SE(u32 dat, u32 index) -> u32 {
	bool isSigned = (dat >> (index - 1)) != 0;
	u32 signed = ((1 << (32 - index)) - 1) << index;
	u32 mask = (1 << index) - 1;
	return if isSigned {
		dat & mask | signed
	} else {
		dat & mask
	};
}

def handleBranch<N>(MipsStates<N> mut states, u32 opcode, u32 insn, u32 rtReg, u32 rs) -> MipsStates<N> {
	bool mut shouldBranch = false;
	u32 rtv = (insn >> 16) & 0x0000001F;
	u32 rt = states.cur.regs[rtReg];
	shouldBranch = 	if opcode == 4 || opcode == 5 { // beq/bne
		(rs ==rt && opcode == 4) || (rs != rt && opcode == 5)
	} else {
		if opcode == 6 {
			rs >= 0x80000000 || rs == 0 // blez
		} else {
			if opcode == 7 {
				rs < 0x80000000 && rs != 0 // bgtz
			} else {
				if opcode == 1 {

					if rtv == 0 { // bltz
						rs > 0x80000000
					} else {
						if rtv == 1 { // bgez
							rs <= 0x80000000
						} else {
							false
						}
					}
				} else {
					false
				}
			}
		}
	};

	u32 prevPC = states.cur.pc;
	states.cur.pc = states.cur.nextPC;
	states.cur.nextPC = if shouldBranch {
		prevPC + 4 + (SE(insn & 0x0000FFFF, 16) << 2)
	} else {
		states.cur.pc + 4
	};

	return states;
}

def handleRItypeInsts<N>(MipsStates<N> mut states, u32 insn, u32 opcode) -> MipsStates<N> {
	u32 mut rs = 0;
	u32 mut rt = 0;
	u32 mut rtReg = (insn >> 16) & 0x0000001F;
	u32 mut rdReg = 0;

	rs = states.cur.regs[(insn >> 21) & 0x0000001F];
	rdReg = opcode == 0 || opcode == 0x0000001C ? (insn >> 11) & 0x0000001F : rtReg;

	rt = if opcode == 0 || opcode == 0x0000001C {
		states.cur.regs[rtReg]
	} else {
		if opcode < 0x00000020 {
			if opcode == 0x0000000C || opcode == 0x0000000D || opcode == 0x0000000E {
				insn & 0x0000FFFF
			} else {
				SE(insn & 0x0000FFFF, 16)
			}
		} else {
			if opcode >= 0x00000028 || opcode == 0x00000022 || opcode == 0x00000026 {
				states.cur.regs[rtReg]
			} else {
				0
			}
		}
	};

	return if (opcode >= 4 && opcode <= 8) || opcode == 1 {
		handleBranch(states, opcode, insn, rtReg, rs)
	} else {
		states
	};
}

def execute<N>(MipsStates<N> mut states) -> MipsStates<N> {
	u32 mut inst = 0;
	inst = states.memory[states.cur.pc];
//  assert(inst == nextStates.opcode);

	u32 opcode = inst >> 26;

	return if opcode == 2 || opcode == 3 {
		handleJump(states, opcode == 2 ? 0 : 31, (opcode & 0x03FFFFFF) << 2)
	} else {
		handleRItypeInsts(states, inst, opcode)
	};
}

def check_instruction<N>(MipsStates<N> mut states, trace_record nextStates) -> MipsStates<N> {

	assert(states.cur.pc < N);

	states = execute(states);
	
	states.cur.cycle = states.cur.cycle + 1;
	assert(states.cur == nextStates);
	return states;
}

def do_check<recordSize, memSize>(
	trace_record[recordSize] mut trace, 
	u32[memSize] mut mem_image,
	u32 start_pc,
	u32[memSize] final_mem_image) -> u32 {
	
	u32 mut ret = 0;
	// check initial trace
	MipsStates<memSize> mut states = MipsStates{
		cur: trace[0],
		memory: mem_image
	};

	ret = verify_initial_state(states.cur, start_pc);
//	states.cur.start = false;

	// check every instruction trace 
	for u32 i in 1..recordSize {
		states = check_instruction(states, trace[i]);
	}

	// check final memory image
	assert(states.memory == final_mem_image);

	return 0;
}

def main(private trace_record[1] mut trace, 
	u32[4] mut mem_image,
	u32 start_pc, u32[4] final_mem_image) -> u32 {
        
	return do_check(trace, mem_image, start_pc, mem_image);
}

// example input: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
