struct mem_access {
	u32 addr;
	u32 value;
	bool is_write; 
}

struct trace_record {
	u32 cycle;
	u32 opcode;
	u32 pc;
	u32[32] regs;
	u32 hi;
	u32 lo;
	mem_access mem;
	bool start;
	bool finish;
}

struct MipsStates<N> {
	trace_record cur;
	u32[N] memory;
}

def verify_initial_state(trace_record record, u32 start_pc) -> u32 {
	assert(record.cycle == 0);
	assert(record.opcode == 0);
	assert(record.pc == start_pc);
	assert(record.regs == [0;32]);
	assert(record.hi == 0);
	assert(record.lo == 0);
	assert(record.mem == mem_access {addr: 0, value: 0, is_write: false});
	assert(record.start == true);
	assert(record.finish == false);
	return 0;
}

def check_instruction<N>(MipsStates<N> mut states, trace_record nextStates) -> MipsStates<N> {

	assert(states.cur.pc < N);
	u32 mut inst = 0;
	inst = states.memory[states.cur.pc];
	assert(inst == nextStates.opcode);

	// TODO: decode instruction, update MipsStates and do check on the instruction function
	
	states.cur.cycle = states.cur.cycle + 1;
	assert(states.cur == nextStates);
	return states;
}

def do_check<recordSize, memSize>(
	trace_record[recordSize] mut trace, 
	u32[memSize] mut mem_image,
	u32 start_pc,
	u32[memSize] final_mem_image) -> u32 {
	
	u32 mut ret = 0;
	// check initial trace
	MipsStates<memSize> mut states = MipsStates{
		cur: trace[0],
		memory: mem_image
	};

	ret = verify_initial_state(states.cur, start_pc);
	states.cur.start = false;

	// check every instruction trace 
	for u32 i in 1..recordSize {
		states = check_instruction(states, trace[i]);
	}

	// check final memory image
	assert(states.memory == final_mem_image);

	return 0;
}

def main(private trace_record[1] mut trace, 
	u32[4] mut mem_image,
	u32 start_pc, u32[4] final_mem_image) -> u32 {
        
	return do_check(trace, mem_image, start_pc, mem_image);
}

// example input: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
