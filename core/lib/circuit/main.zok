struct trace_record {
	u32 cycle;
	u32 pc;
	u32 nextPC;
	u32 lo;
	u32 hi;
	u32[32] regs;
	u32[32] preImageKey;
	u32 preImageOffset;
	u32 heap;
	u8 exitCode;
	bool exited;
//	u32 opcode;
//	u32 addr;
//	u32 memValue;
//	bool isWrite;
//	bool start;
}

struct MipsStates<N> {
	trace_record cur;
	u32[N] memory;
}

def verify_initial_state(trace_record record, u32 start_pc) -> u32 {
	assert(record.cycle == 0);
	assert(record.nextPC == start_pc + 4);
	assert(record.pc == start_pc);
	assert(record.lo == 0);
	assert(record.hi == 0);
	assert(record.regs == [0;32]);
	assert(record.preImageKey == [0;32]);
	assert(record.heap == 0x20000000);
	assert(record.exitCode == 0);
	assert(record.exited == false);
//	assert(record.addr == 0);
//	assert(record.opcode == 0);
//	assert(record.memValue == 0);
//	assert(record.isWrite == 0);
//	assert(record.start == true);

	return 0;
}

def updateReg<N>(MipsStates<N> mut states, u32 reg, u32 value) -> MipsStates<N> {
	assert(reg != 0);
	assert(reg <= 31);
	states.cur.regs[reg] = value;
	return states;
}

def handleJump<N>(MipsStates<N> mut states, u32 link, u32 dest) -> MipsStates<N> {
	u32 prevPC = states.cur.pc;
	states.cur.pc = states.cur.nextPC;
	states.cur.nextPC = dest;
	return if link == 0 {
		states
	} else {
		updateReg(states, link, prevPC + 8)
	};
}

def execute<N>(MipsStates<N> mut states) -> MipsStates<N> {
	u32 mut inst = 0;
	inst = states.memory[states.cur.pc];
//  assert(inst == nextStates.opcode);

	u32 opcode = inst >> 26;

	states = if opcode == 2 || opcode == 3 {
		handleJump(states, opcode == 2 ? 0 : 31, (opcode & 0x03FFFFFF) << 2)
	} else {
		states
	};

	return states;
}

def check_instruction<N>(MipsStates<N> mut states, trace_record nextStates) -> MipsStates<N> {

	assert(states.cur.pc < N);

	states = execute(states);
	
	states.cur.cycle = states.cur.cycle + 1;
	assert(states.cur == nextStates);
	return states;
}

def do_check<recordSize, memSize>(
	trace_record[recordSize] mut trace, 
	u32[memSize] mut mem_image,
	u32 start_pc,
	u32[memSize] final_mem_image) -> u32 {
	
	u32 mut ret = 0;
	// check initial trace
	MipsStates<memSize> mut states = MipsStates{
		cur: trace[0],
		memory: mem_image
	};

	ret = verify_initial_state(states.cur, start_pc);
//	states.cur.start = false;

	// check every instruction trace 
	for u32 i in 1..recordSize {
		states = check_instruction(states, trace[i]);
	}

	// check final memory image
	assert(states.memory == final_mem_image);

	return 0;
}

def main(private trace_record[1] mut trace, 
	u32[4] mut mem_image,
	u32 start_pc, u32[4] final_mem_image) -> u32 {
        
	return do_check(trace, mem_image, start_pc, mem_image);
}

// example input: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
